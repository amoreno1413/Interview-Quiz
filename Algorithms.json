 {
    "What is a Data Structure?": [
    "A data structure is a storage format that defines the way data is stored, organized, and manipulated.",
    "A data structure is a specific piece of data used to represent information.",
    "A data structure is a specific type of programming language used for data manipulation."
    ],
    "What is an Array?": [
    "An array is commonly referred to as a collection of items stored at contiguous memory locations.",
    "An array is commonly referred to as a collection of items stored at non-contiguous memory locations.",
    "An array is commonly referred to as a collection of items stored at random memory locations."
    ],
    "What is a Linked List?": [
    "A linked list is a type of data structure that has a sequence of nodes, each node points to the next node.",
    "A linked list is a type of data structure that has a sequence of nodes, each node points to the previous node.",
    "A linked list is a type of data structure that has a sequence of vertex, each vertex points to the next vertex."
    ],
    "What is LIFO?": [
    "LIFO stands for Last In First Out.",
    "LIFO stands for Last Inactive First Offline",
    "LIFO stands for Least Invoked First Obliterated."
    ],

    "What is FIFO?": [
    "FIFO stands for First In First Out.",
    "FIFO stands for Fast Input Fast Output.",
    "FIFO stands for Fast Insertions Fast Operations"
    ],

    "What is Recursion?": [
    "Recursion refers to a function calling itself based on a terminating condition.",
    "Recursion is a term used in mathematics for solving complex problems step by step.",
    "Recursion refers to a function calling other functions."
    ],

   "What is Deque?" : [
   "Double-ended queue",
   "An acronym for 'Data Queue'",
   "A double-ended stack"
   ],

   "What sorting algorithm has the quickest runtime?" : [
      "QuickSort",
      "MergeSort",
      "InsertionSort"
   ],

   "What is the time complexity of a bubble sort algorithm?": [
  "The time complexity of bubble sort is O(n^2), where 'n' is the size of the input data.",
  "The time complexity of bubble sort is O(n), where 'n' is the size of the input data.",
  "The time complexity of bubble sort is O(1), regardless of input size."
  ],

  "What is the time complexity of a quicksort algorithm in the average case?": [
  "The average-case time complexity of quicksort is O(n log n), where 'n' is the size of the input data.",
  "The average-case time complexity of quicksort is O(n^2), where 'n' is the size of the input data.",
  "The average-case time complexity of quicksort is O(1), regardless of input size."
  ],

  "What is the time complexity of a selection sort algorithm?": [
  "The time complexity of selection sort is O(n^2), where 'n' is the size of the input data.",
  "The time complexity of selection sort is O(log n), where 'n' is the size of the input data.",
  "The time complexity of selection sort is O(1), regardless of input size."
  ],

  "What is the time complexity of an insertion sort algorithm in the average case?": [
  "The average-case time complexity of insertion sort is O(n^2), where 'n' is the size of the input data.",
  "The average-case time complexity of insertion sort is O(n log n), where 'n' is the size of the input data.",
  "The average-case time complexity of insertion sort is O(1), regardless of input size."
  ],

  "What is the time complexity of a merge sort algorithm?": [
  "The time complexity of merge sort is O(n log n), where 'n' is the size of the input data.",
  "The time complexity of merge sort is O(n^2), where 'n' is the size of the input data.",
  "The time complexity of merge sort is O(1), regardless of input size."
  ],
 "What is Quicksort?": [
      "Quicksort is a highly efficient, comparison-based sorting algorithm known for its fast average-case performance.",
      "Quicksort is a highly inefficient, comparison-based sorting algorithm known for its slow average-case performance.",
      "Quicksort is a highly efficient, comparison-based sorting algorithm known for its slow average-case performance."
  ],
  "How does Quicksort divide and sort elements in an array?": [
      "Quicksort selects a 'pivot' element, divides the array into two subarrays - elements less than the pivot and elements greater than the pivot - and then recursively sorts these subarrays.",
      "Quicksort always selects the middle element as the pivot to ensure a balanced split.",
      "Quicksort divides the array into three subarrays: elements less than the pivot, elements equal to the pivot, and elements greater than the pivot."
  ],
  "What is the runtime complexity of Quicksort in the average case?": [
      "The average-case runtime complexity of Quicksort is O(n log n), making it one of the fastest sorting algorithms for most scenarios.",
      "Its average-case runtime complexity is O(n^2), making it inefficient for most data sets.",
      "Quicksort has a constant runtime complexity of O(1) in the average case."
  ],
  "Explain the worst-case scenario for Quicksort and how it can be mitigated.": [
      "The worst-case scenario occurs when the pivot selection consistently results in highly unbalanced subarrays, leading to O(n^2) complexity. This can be mitigated by using techniques like random or median-of-three pivot selection.",
      "The worst-case scenario is when the array is already sorted, resulting in a runtime complexity of O(n log n). This can be mitigated by using pivot selection algorithms to ensure balanced subarrays.",
      "Quicksort has no worst-case scenario, and its performance is always optimal."
  ],
  "Provide an example scenario where Quicksort is used in real-life applications and discuss its time complexity in that context.": [
      "Quicksort is commonly used in sorting large datasets in databases, where its O(n log n) time complexity is crucial for efficient data retrieval.",
      "It's applied in computer graphics for tasks like rendering and depth buffering. Its time complexity impacts the rendering speed in video games and simulations.",
      "Quicksort is used in natural language processing for tasks like text search and pattern matching. Its time complexity influences the efficiency of text processing applications."
  ],
 "What is Depth-First Search (DFS)?": [
      "Depth-First Search is a graph traversal algorithm that explores as far down a branch as possible before backtracking.",
      "Depth-First Search is a graph traversal algorithm that explores all the neighbors of a node before moving to its children.",
      "Depth-First Search is a graph traversal algorithm that explores every node randomly."
  ],
  "How does DFS operate when exploring a graph?": [
      "DFS explores a path as deeply as possible before backtracking to explore other branches, making it a recursive approach.",
      "DFS operates by traversing a graph in a random order, visiting nodes based on a random selection.",
      "DFS operates by starting at the last node of the graph and moving backward to the first node."
  ],
  "What is the runtime complexity of DFS when applied to a graph?": [
      "The runtime complexity of DFS is O(V + E), where V is the number of vertices and E is the number of edges.",
      "The runtime complexity of DFS is O(E LOG V), where V is the number of vertices and E is the number of edges.",
      "The runtime complexity of DFS is O(V * E), where V is the number of vertices and E is the number of edges."
  ],
  "Can DFS handle graphs with weighted edges, and what are the implications?": [
      "DFS can handle weighted graphs but doesn't guarantee the shortest path. It may not find the optimal solution in such cases.",
      "DFS is designed exclusively for unweighted graphs and cannot process weighted edges.",
      "Weighted edges have no effect on DFS since it doesn't consider edge weights."
  ],
  "Provide an example scenario where DFS is used in real-life applications and discuss its time complexity in that context.": [
      "DFS is applied in maze-solving algorithms to find paths. Its time complexity is reasonable for small mazes.",
      "It's used in solving puzzles like Sudoku and the N-Queens problem. Its time complexity is essential for solving complex puzzles.",
      "DFS is employed in analyzing and optimizing decision trees in artificial intelligence. Its time complexity affects the speed of decision-making processes."
  ],
 "What is Breadth-First Search (BFS)?": [
      "Breadth-First Search is a graph traversal algorithm that explores all the neighbors of a node before moving to its children.",
      "Breadth-First Search is a graph traversal algorithm that explores as far down a branch as possible before backtracking.",
      "Breadth-First Search is a graph traversal algorithm that explores as far up a branch as possible before backtracking."
  ],
  "How does BFS determine the shortest path in an unweighted graph?": [
      "BFS guarantees the shortest path by exploring nodes level by level, ensuring the first encountered path is the shortest.",
      "It uses heuristics to estimate the shortest path, not guaranteeing optimality.",
      "BFS randomly selects nodes to estimate the shortest path."
  ],
  "What is the runtime complexity of BFS when applied to a graph?": [
      "The runtime complexity of BFS is O(V + E), where V is the number of vertices and E is the number of edges.",
      "The runtime complexity of BFS is O(V * E), where V is the number of vertices and E is the number of edges.",
      "The runtime complexity of BFS is O(E Log V), where V is the number of vertices and E is the number of edges."
  ],
  "Can BFS handle graphs with weighted edges, and what are the implications?": [
      "BFS is designed for unweighted graphs and doesn't account for weighted edges. It doesn't guarantee the shortest path in weighted graphs.",
      "BFS works optimally with weighted edges and produces the shortest path regardless of edge weights.",
      "Weighted edges have no effect on BFS since it doesn't consider edge weights."
  ],
  "Provide an example scenario where BFS is used in real-life applications and discuss its time complexity in that context.": [
      "BFS is employed in social network analysis to find the shortest connection between users. Its time complexity is reasonable for large social networks.",
      "It's used in web crawling to index web pages efficiently. Its time complexity plays a crucial role in keeping search engines up to date.",
      "BFS is applied in recommendation systems to find the shortest path between products or content. Its time complexity impacts user experience."
  ],
  "What are Divide and Conquer algorithms?": [
    "Divide and Conquer algorithms break a problem into smaller, independent parts for individual solutions.",
    "Divide and conquer algorithms are management techniques for breaking down large projects into manageable tasks.",
    "Divide and conquer algorithms are problem-solving approaches that involve teamwork and collaboration."
  ],
  "How do Divide and Conquer algorithms work?": [
    "Break a problem into smaller parts, solve them, and then combine into a single comprehensive solution.",
    "Divide and conquer algorithms work by physically splitting computer components into smaller parts for more efficient processing.",
    "Divide and conquer algorithms work by dividing computer memory into multiple segments to enhance data storage."
  ],
  "What is the 2-Pointer Appoach?": [
    "A 2-Pointer approach is a technique to efficiently solve problems by processing two elements of a data structure, usually in the context of a loop.",
    "A 2-Pointer approach is a strategy that uses only two memory addresses for storing data.",
    "A 2-Pointer approach is a strategy that involves using 2 variables to a solve a problem."
  ],
  "How does a 2-Pointer algorithm work in the context of linked lists?": [
    "A 2-Pointer algorithm involves mainting two pointers at different positions in the linked list and moving them based on certain conditions.",
    "A 2-Pointer algorithm utilizes only two linked lists to perfom operations based on certain conditions.",
    "A 2-Pointer algirhm is designed specifically for sorting linked lists."
  ],
  "In what scenarios is a 2-pointer approach beneficial for solving problems?":[
    "A 2-Pointer approach is particularly useful for problems involving searching or comparison of elements in a sorted array or linked list.",
    "A 2-Pointer approach is mainly suitable for problems where more than two pointers are needed for efficient computation.",
    "A 2-Pointer apporach is limited to problems related to binary search and cannot be applied elsewhere."
  ],
  "What is the key charateristic of data for binary search to be effective?": [
    "Binary search is effective when the data is sorted in ascending or descending order.",
    "Binary search works optimally with unsorted data.",
    "Binary search is most efficient when the data is sorted in a linked list."
  ],
  "How does binary search operate on a sorted array?": [
    "Binary search compares the target value to the middle element of the array and eliminates half of the remaining elements based on the comparison result.",
    "Binary search always starts from the first element of the array and compares it with the target value.",
    "Binary search randomly selects elements to compare with the target value."
  ],
  "What is the time complexity of binary search?": [
    "The time complexity of binary search is O(Log n), where n is the number of elements in the array.",
    "The time complexity of binary search is O(n), where n is the number of elements in the array.",
    "The time complexity of binary search is O(n Log n), where n is the number of elements in the array."
  ],
  "What defines the concept of a sliding window in algorithmic problem-solving?":[
    "A sliding window is a subarray of fixed size that 'slides' through the larger array, allowing for efficient computation of certain problems.",
    "A sliding window is a visual representation of array elements shifting randomly.",
    "A sliding window is a technique exclusive to linked lsits and cannot be applied to arrays."
  ],
  "How does the sliding window technique optimize the solution for certain problems": [
    "The sliding window technique optimizes solutions by avoiding the recomputation of overlapping subproblems.",
    "The sliding window technique has no impact on the optimization of algorithmic solutions.",
    "The sliding window technique is only useful for problems with very small input sizes."
  ],
  "In what scenarios is the sliding window approach not suitable?": [
    "The sliding window approach may not be suitable for problems where the order of elements in the array is not relevant.",
    "The sliding window approach is univerally applicable and is suitable for all types of problems.",
    "The sliding window approach is limited to problems with a fixed-size window and cannot adapt to variable-sized windows."
  ],
  "What is the primary characteristic of problems that are solved using backtracking?": [
    "Backtracking is typically used for problems where the solution is built incrementally and can be abandoned if it's determined that the current path cannot lead to a valid solution.",
    "Backtracking is exclusively applicable to problems with a predefined and straightforward solution path.",
    "Backtracking is designed for problems with a fixed and non-modifiable solution space."
  ],
  "How does backtracking handle the exploration of solution paths?": [
    "Backtracking explores solution paths by trying out different choices, and if a choice doesn't lead to a solution, it backtracks to the previous decision point and explores other choices.",
    "Backtracking explores solution paths sequentially without making any choices.",
    "Backtracking only explores the solution path in the forward direction and does not backtrack to previous decision points."
  ],
  "What is the role of pruning in backtracking algorithms?": [
    "Pruning in backtracking algorithms involves stopping the exploration of a particular path if it's determined that it cannot lead to a valid solution.",
    "Pruning is not a concept associated with backtracking, as backtracking always explores all possible paths.",
    "Pruning in backtracking is the process of selecting the most promising solution path without exploring other alternatives."
  ],
  "What 3 Problems are best suited for the 2-Pointer Approach?":[
    "Valid Palidrome, Sorted 2-Sum, 3Sum",
    "Unsorted 2-Sum, Valid Anagram, Top K Frequent Elements",
    "Best Time to Buy and Sell Stock, Longest Substring Without Repeating Characters, Permutation in String"
  ],
  "What 3 Problems are best suited for Binary Search?":[
    "Binary Search, Search a 2D Matrix, Koko Eating Bananas",
    "Unsorted 2-Sum, Valid Anagram, Top K Frequent Elements",
    "Contains Duplicate, Product of Array Except Self, Valid Sudoku"
  ],
  "What 3 Problems are best suited for Sliding Window?":[
    "Best Time to Buy and Sell Stock, Longest Substring Without Repeating Characters, Permutation in String",
    "Binary Search, Search a 2D Matrix, Koko Eating Bananas",
    "Contains Duplicate, Product of Array Except Self, Valid Sudoku"
  ],
  "What 3 Problems are best suited for Backtracking?":[
    "Combination Sum, Word Search, N Queens",
    "Binary Search, Search a 2D Matrix, Koko Eating Bananas",
    "Contains Duplicate, Product of Array Except Self, Valid Sudoku"
  ]
}
